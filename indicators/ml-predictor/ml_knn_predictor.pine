//@version=5
indicator("ML Price Predictor (KNN)", overlay=true, shorttitle="ML KNN", max_bars_back=500)

// ============================================================================
// INPUT PARAMETERS
// ============================================================================
// Prediction Settings
lookback_bars = input.int(100, "Historical Lookback Bars", minval=50, maxval=200, group="Prediction Settings")
k_neighbors = input.int(10, "K Nearest Neighbors", minval=5, maxval=20, group="Prediction Settings")
prediction_horizon = input.int(10, "Predict N Bars Ahead", minval=5, maxval=30, group="Prediction Settings")

// Feature Weights
weight_rsi = input.float(1.0, "RSI Weight", minval=0.1, maxval=2.0, step=0.1, group="Feature Weights")
weight_volume = input.float(0.8, "Volume Weight", minval=0.1, maxval=2.0, step=0.1, group="Feature Weights")
weight_trend = input.float(1.2, "Trend Weight", minval=0.1, maxval=2.0, step=0.1, group="Feature Weights")
weight_price_pos = input.float(1.0, "Price Position Weight", minval=0.1, maxval=2.0, step=0.1, group="Feature Weights")

// Display Settings
show_prediction_label = input.bool(true, "Show Prediction Label", group="Display")
panel_position = input.string("Top Right", "Panel Position", options=["Top Left", "Top Center", "Top Right", "Middle Left", "Middle Center", "Middle Right", "Bottom Left", "Bottom Center", "Bottom Right"], group="Display")
show_target_line = input.bool(true, "Show Target Price Line", group="Display")
show_signals = input.bool(true, "Show Buy/Sell Signals", group="Display")
min_confidence = input.int(50, "Min Confidence for Signals (%)", minval=30, maxval=80, group="Display")

// ============================================================================
// FEATURE CALCULATION FUNCTIONS
// ============================================================================
// Calculate price position in range (0-100)
calc_price_position(len) =>
    highest = ta.highest(high, len)
    lowest = ta.lowest(low, len)
    price_range = highest - lowest
    price_range > 0 ? ((close - lowest) / price_range) * 100 : 50

// Calculate RSI slope (momentum)
calc_rsi_slope(rsi_val) =>
    rsi_val - rsi_val[5]

// Calculate volume ratio (spike detection)
calc_volume_ratio() =>
    avg_vol = ta.sma(volume, 20)
    avg_vol > 0 ? volume / avg_vol : 1.0

// Calculate trend strength (EMA slope)
calc_trend_strength() =>
    ema20 = ta.ema(close, 20)
    ema20_old = ta.ema(close[10], 20)
    ema20_old > 0 ? ((ema20 - ema20_old) / ema20_old) * 100 : 0

// ============================================================================
// CURRENT FEATURES
// ============================================================================
current_rsi = ta.rsi(close, 14)
current_price_pos = calc_price_position(100)
current_rsi_slope = calc_rsi_slope(current_rsi)
current_vol_ratio = calc_volume_ratio()
current_trend = calc_trend_strength()

// ============================================================================
// PATTERN MATCHING ENGINE (K-NEAREST NEIGHBORS)
// ============================================================================
var float[] distances = array.new_float(0)
var float[] outcomes = array.new_float(0)

// Clear arrays
array.clear(distances)
array.clear(outcomes)

// Search for similar patterns in history
if bar_index > lookback_bars + prediction_horizon
    for i = lookback_bars to prediction_horizon
        // Calculate historical features
        hist_rsi = ta.rsi(close[i], 14)
        hist_price_pos = calc_price_position(100)[i]
        hist_rsi_slope = calc_rsi_slope(hist_rsi)
        hist_vol_ratio = calc_volume_ratio()[i]
        hist_trend = calc_trend_strength()[i]
        
        // Calculate feature distance (Euclidean-like)
        distance = 0.0
        
        // RSI similarity
        rsi_diff = math.abs(current_rsi - hist_rsi) / 100
        distance += rsi_diff * rsi_diff * weight_rsi
        
        // Price position similarity
        price_pos_diff = math.abs(current_price_pos - hist_price_pos) / 100
        distance += price_pos_diff * price_pos_diff * weight_price_pos
        
        // Volume similarity
        vol_diff = math.abs(current_vol_ratio - hist_vol_ratio)
        distance += vol_diff * vol_diff * weight_volume
        
        // Trend similarity
        trend_diff = math.abs(current_trend - hist_trend) / 10
        distance += trend_diff * trend_diff * weight_trend
        
        distance := math.sqrt(distance)
        
        // Calculate outcome (what happened N bars later)
        outcome_price = close[i - prediction_horizon]
        current_price = close[i]
        outcome_pct = ((outcome_price - current_price) / current_price) * 100
        
        // Store distance and outcome
        array.push(distances, distance)
        array.push(outcomes, outcome_pct)

// ============================================================================
// FIND K NEAREST NEIGHBORS
// ============================================================================
var float[] top_k_outcomes = array.new_float(0)
array.clear(top_k_outcomes)

if array.size(distances) >= k_neighbors
    // Simple selection of K smallest distances
    for k = 0 to k_neighbors - 1
        min_dist = 999999.0
        min_idx = 0
        
        // Find minimum distance not yet selected
        for i = 0 to array.size(distances) - 1
            dist = array.get(distances, i)
            if dist < min_dist
                // Check if not already selected
                already_selected = false
                if array.size(top_k_outcomes) > 0
                    for j = 0 to array.size(top_k_outcomes) - 1
                        if math.abs(array.get(outcomes, i) - array.get(top_k_outcomes, j)) < 0.001
                            already_selected := true
                            break
                
                if not already_selected
                    min_dist := dist
                    min_idx := i
        
        // Add to top K
        if min_dist < 999999.0
            array.push(top_k_outcomes, array.get(outcomes, min_idx))

// ============================================================================
// CALCULATE PREDICTION
// ============================================================================
var float predicted_change = 0.0
var float confidence_score = 0.0
var string direction = "SIDEWAYS"

if array.size(top_k_outcomes) > 0
    // Average of top K outcomes
    sum = 0.0
    for i = 0 to array.size(top_k_outcomes) - 1
        sum += array.get(top_k_outcomes, i)
    
    predicted_change := sum / array.size(top_k_outcomes)
    
    // Calculate confidence based on consistency of predictions
    variance = 0.0
    for i = 0 to array.size(top_k_outcomes) - 1
        diff = array.get(top_k_outcomes, i) - predicted_change
        variance += diff * diff
    
    variance := variance / array.size(top_k_outcomes)
    std_dev = math.sqrt(variance)
    
    // Lower variance = higher confidence
    confidence_score := math.min(100, 100 / (1 + std_dev * 2))
    
    // Classify direction
    if predicted_change > 2.0
        direction := "STRONG UP üöÄ"
    else if predicted_change > 0.5
        direction := "UP ‚¨ÜÔ∏è"
    else if predicted_change < -2.0
        direction := "STRONG DOWN üìâ"
    else if predicted_change < -0.5
        direction := "DOWN ‚ÜòÔ∏è"
    else
        direction := "SIDEWAYS ‚ÜîÔ∏è"

// ============================================================================
// TARGET PRICE
// ============================================================================
target_price = close * (1 + predicted_change / 100)

// ============================================================================
// VISUALIZATION
// ============================================================================
// Calculate stop loss and take profit levels
stop_loss_pct = 2.0
take_profit_pct = math.abs(predicted_change) * 1.5

sl_price = predicted_change > 0 ? close * (1 - stop_loss_pct / 100) : close * (1 + stop_loss_pct / 100)
tp_price = predicted_change > 0 ? close * (1 + take_profit_pct / 100) : close * (1 - take_profit_pct / 100)

// Prediction panel with table (compact and clean)
if show_prediction_label
    // Convert position string to position constant
    panel_pos = panel_position == "Top Left" ? position.top_left : panel_position == "Top Center" ? position.top_center : panel_position == "Top Right" ? position.top_right : panel_position == "Middle Left" ? position.middle_left : panel_position == "Middle Center" ? position.middle_center : panel_position == "Middle Right" ? position.middle_right : panel_position == "Bottom Left" ? position.bottom_left : panel_position == "Bottom Center" ? position.bottom_center : position.bottom_right
    
    var table pred_table = table.new(panel_pos, 2, 7, border_width=2)
    
    // Header color based on directionA
    header_color = predicted_change > 0 ? color.new(color.green, 20) : color.new(color.red, 20)
    text_color = color.white
    
    // Row 0: Direction header
    table.cell(pred_table, 0, 0, "ML PREDICTION", bgcolor=header_color, text_color=text_color, text_size=size.normal, text_font_family=font.family_monospace)
    table.cell(pred_table, 1, 0, direction, bgcolor=header_color, text_color=text_color, text_size=size.normal)
    
    // Row 1: Target
    table.cell(pred_table, 0, 1, "Target", bgcolor=color.new(color.gray, 80), text_color=text_color, text_size=size.small)
    table.cell(pred_table, 1, 1, str.tostring(target_price, "#.##"), bgcolor=color.new(color.gray, 90), text_color=text_color, text_size=size.small)
    
    // Row 2: Change %
    table.cell(pred_table, 0, 2, "Change", bgcolor=color.new(color.gray, 80), text_color=text_color, text_size=size.small)
    table.cell(pred_table, 1, 2, str.tostring(predicted_change, "#.##") + "%", bgcolor=color.new(color.gray, 90), text_color=predicted_change > 0 ? color.lime : color.red, text_size=size.small)
    
    // Row 3: Confidence
    conf_color = confidence_score > 70 ? color.lime : confidence_score > 50 ? color.orange : color.red
    table.cell(pred_table, 0, 3, "Confidence", bgcolor=color.new(color.gray, 80), text_color=text_color, text_size=size.small)
    table.cell(pred_table, 1, 3, str.tostring(confidence_score, "#") + "%", bgcolor=color.new(color.gray, 90), text_color=conf_color, text_size=size.small)
    
    // Row 4: R/R
    risk_reward = math.abs(predicted_change) / stop_loss_pct
    table.cell(pred_table, 0, 4, "R:R", bgcolor=color.new(color.gray, 80), text_color=text_color, text_size=size.small)
    table.cell(pred_table, 1, 4, str.tostring(risk_reward, "#.#") + ":1", bgcolor=color.new(color.gray, 90), text_color=text_color, text_size=size.small)
    
    // Row 5: TP
    table.cell(pred_table, 0, 5, "TP", bgcolor=color.new(color.green, 70), text_color=text_color, text_size=size.small)
    table.cell(pred_table, 1, 5, str.tostring(tp_price, "#.##"), bgcolor=color.new(color.green, 80), text_color=text_color, text_size=size.small)
    
    // Row 6: SL
    table.cell(pred_table, 0, 6, "SL", bgcolor=color.new(color.red, 70), text_color=text_color, text_size=size.small)
    table.cell(pred_table, 1, 6, str.tostring(sl_price, "#.##"), bgcolor=color.new(color.red, 80), text_color=text_color, text_size=size.small)

// Confidence indicator bar (vertical bar on right side)
if barstate.islast and show_prediction_label
    var line conf_bar = na
    var label conf_label = na
    line.delete(conf_bar)
    label.delete(conf_label)
    
    // Draw confidence bar
    bar_bottom = low * 0.98
    bar_height = (high - low) * 0.3
    conf_top = bar_bottom + (bar_height * confidence_score / 100)
    
    conf_color = confidence_score > 70 ? color.green : confidence_score > 50 ? color.orange : color.red
    conf_bar := line.new(bar_index + 2, bar_bottom, bar_index + 2, conf_top, color=conf_color, width=8)
    
    conf_label := label.new(bar_index + 2, conf_top, str.tostring(confidence_score, "#") + "%", style=label.style_none, color=color.new(color.white, 100), textcolor=conf_color, size=size.small)

// Target line with annotation
if show_target_line and barstate.islast
    var line target_line = na
    var label target_label = na
    line.delete(target_line)
    label.delete(target_label)
    
    line_color = predicted_change > 0 ? color.new(color.green, 30) : color.new(color.red, 30)
    target_line := line.new(bar_index - 5, target_price, bar_index + prediction_horizon, target_price, color=line_color, width=2, style=line.style_dashed, extend=extend.right)
    
    target_label := label.new(bar_index + prediction_horizon, target_price, "üéØ " + str.tostring(predicted_change, "#.#") + "%", style=label.style_label_left, color=line_color, textcolor=color.white, size=size.small)

// Stop Loss line
if show_target_line and barstate.islast and confidence_score > min_confidence
    var line sl_line = na
    var label sl_label = na
    line.delete(sl_line)
    label.delete(sl_label)
    
    sl_line := line.new(bar_index - 3, sl_price, bar_index + 5, sl_price, color=color.new(color.red, 50), width=1, style=line.style_dotted)
    sl_label := label.new(bar_index + 5, sl_price, "‚ùå SL", style=label.style_label_left, color=color.new(color.red, 30), textcolor=color.white, size=size.tiny)

// Take Profit line
if show_target_line and barstate.islast and confidence_score > min_confidence
    var line tp_line = na
    var label tp_label = na
    line.delete(tp_line)
    label.delete(tp_label)
    
    tp_line := line.new(bar_index - 3, tp_price, bar_index + 5, tp_price, color=color.new(color.green, 50), width=1, style=line.style_dotted)
    tp_label := label.new(bar_index + 5, tp_price, "‚úÖ TP", style=label.style_label_left, color=color.new(color.green, 30), textcolor=color.white, size=size.tiny)

// Prediction zone (shaded area between current price and target)
if show_target_line and barstate.islast
    var box pred_zone = na
    box.delete(pred_zone)
    
    zone_color = predicted_change > 0 ? color.new(color.green, 93) : color.new(color.red, 93)
    zone_top = math.max(close, target_price)
    zone_bottom = math.min(close, target_price)
    
    pred_zone := box.new(bar_index, zone_top, bar_index + prediction_horizon, zone_bottom, border_color=color.new(color.gray, 80), bgcolor=zone_color, border_width=1, border_style=line.style_dashed)

// EMA lines for context
show_ema = input.bool(true, "Show EMA Lines", group="Display")
ema20 = ta.ema(close, 20)
ema50 = ta.ema(close, 50)

plot(show_ema ? ema20 : na, "EMA 20", color=color.new(color.blue, 30), linewidth=1)
plot(show_ema ? ema50 : na, "EMA 50", color=color.new(color.orange, 30), linewidth=1)

// Buy/Sell signals with enhanced conditions
buy_signal = show_signals and predicted_change > 1.5 and confidence_score >= min_confidence and str.contains(direction, "UP")
sell_signal = show_signals and predicted_change < -1.5 and confidence_score >= min_confidence and str.contains(direction, "DOWN")

plotshape(buy_signal, title="BUY Signal", style=shape.triangleup, location=location.belowbar, color=color.new(color.green, 0), size=size.normal, text="BUY")
plotshape(sell_signal, title="SELL Signal", style=shape.triangledown, location=location.abovebar, color=color.new(color.red, 0), size=size.normal, text="SELL")

// Enhanced background colors with gradient effect
strong_bull_bg = predicted_change > 3 and confidence_score > 70
bull_bg = predicted_change > 1.5 and predicted_change <= 3 and confidence_score > 60
strong_bear_bg = predicted_change < -3 and confidence_score > 70
bear_bg = predicted_change < -1.5 and predicted_change >= -3 and confidence_score > 60

bgcolor(strong_bull_bg ? color.new(color.green, 90) : bull_bg ? color.new(color.green, 95) : na, title="Bullish BG")
bgcolor(strong_bear_bg ? color.new(color.red, 90) : bear_bg ? color.new(color.red, 95) : na, title="Bearish BG")

// Plot confidence as a histogram at bottom (optional)
show_conf_histogram = input.bool(false, "Show Confidence Histogram", group="Display")
hline(0, "Zero", color=color.new(color.gray, 80), linestyle=hline.style_dotted)
plot(show_conf_histogram ? confidence_score - 50 : na, "Confidence", color=confidence_score > 60 ? color.green : confidence_score > 40 ? color.orange : color.red, style=plot.style_histogram, linewidth=3)

// ============================================================================
// ALERTS
// ============================================================================
alertcondition(buy_signal, title="ML Buy Signal", message="ü§ñ ML Predictor: BUY Signal!\nüìä Target: {{target_price}}\nüíØ Confidence: {{confidence_score}}%")
alertcondition(sell_signal, title="ML Sell Signal", message="ü§ñ ML Predictor: SELL Signal!\nüìä Target: {{target_price}}\nüíØ Confidence: {{confidence_score}}%")
alertcondition(confidence_score > 80, title="High Confidence Alert", message="‚ö° Very high confidence prediction detected! Check chart.")

